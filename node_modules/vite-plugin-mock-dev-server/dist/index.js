// src/plugin.ts
import { toArray as toArray4 } from "@pengzhanbo/utils";

// src/build.ts
import fs3 from "node:fs";
import fsp2 from "node:fs/promises";
import path3 from "node:path";
import process2 from "node:process";
import { toArray } from "@pengzhanbo/utils";
import fg from "fast-glob";
import isCore from "is-core-module";
import { createFilter } from "@rollup/pluginutils";
import c from "picocolors";

// src/compiler.ts
import fs2, { promises as fsp } from "node:fs";
import { createRequire } from "node:module";
import path2 from "node:path";
import { pathToFileURL } from "node:url";
import { build } from "esbuild";
import JSON5 from "json5";

// src/utils.ts
import fs from "node:fs";
import path from "node:path";
import { parse as queryParse } from "node:querystring";
import { URL as URL2, fileURLToPath } from "node:url";
import os from "node:os";
import Debug from "debug";
import { match } from "path-to-regexp";
function isStream(stream) {
  return stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
}
function isReadableStream(stream) {
  return isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
}
function getDirname(importMetaUrl) {
  return path.dirname(fileURLToPath(importMetaUrl));
}
var debug = Debug("vite:mock-dev-server");
function lookupFile(dir, formats, options) {
  for (const format of formats) {
    const fullPath = path.join(dir, format);
    if (fs.existsSync(fullPath) && fs.statSync(fullPath).isFile()) {
      const result = (options == null ? void 0 : options.pathOnly) ? fullPath : fs.readFileSync(fullPath, "utf-8");
      if (!(options == null ? void 0 : options.predicate) || options.predicate(result))
        return result;
    }
  }
  const parentDir = path.dirname(dir);
  if (parentDir !== dir && (!(options == null ? void 0 : options.rootDir) || parentDir.startsWith(options == null ? void 0 : options.rootDir)))
    return lookupFile(parentDir, formats, options);
}
function ensureProxies(serverProxy = {}) {
  const httpProxies = [];
  const wsProxies = [];
  Object.keys(serverProxy).forEach((key) => {
    var _a, _b;
    const value = serverProxy[key];
    if (typeof value === "string" || !value.ws && !((_a = value.target) == null ? void 0 : _a.toString().startsWith("ws:")) && !((_b = value.target) == null ? void 0 : _b.toString().startsWith("wss:")))
      httpProxies.push(key);
    else
      wsProxies.push(key);
  });
  return { httpProxies, wsProxies };
}
function doesProxyContextMatchUrl(context, url) {
  return context[0] === "^" && new RegExp(context).test(url) || url.startsWith(context);
}
function parseParams(pattern, url) {
  const urlMatch = match(pattern, { decode: decodeURIComponent })(url) || {
    params: {}
  };
  return urlMatch.params || {};
}
function urlParse(input) {
  const url = new URL2(input, "http://example.com");
  const pathname = decodeURIComponent(url.pathname);
  const query = queryParse(url.search.replace(/^\?/, ""));
  return { pathname, query };
}
var windowsSlashRE = /\\/g;
var isWindows = os.platform() === "win32";
function slash(p) {
  return p.replace(windowsSlashRE, "/");
}
function normalizePath(id) {
  return path.posix.normalize(isWindows ? slash(id) : id);
}

// src/compiler.ts
var externalizeDeps = {
  name: "externalize-deps",
  setup(build2) {
    build2.onResolve({ filter: /.*/ }, ({ path: id }) => {
      if (id[0] !== "." && !path2.isAbsolute(id))
        return { external: true };
    });
  }
};
var json5Loader = {
  name: "json5-loader",
  setup(build2) {
    build2.onLoad({ filter: /\.json5$/ }, async ({ path: path4 }) => {
      const content = await fsp.readFile(path4, "utf-8");
      return {
        contents: `export default ${JSON.stringify(JSON5.parse(content))}`,
        loader: "js"
      };
    });
  }
};
var jsonLoader = {
  name: "json-loader",
  setup(build2) {
    build2.onLoad({ filter: /\.json$/ }, async ({ path: path4 }) => {
      const content = await fsp.readFile(path4, "utf-8");
      return {
        contents: `export default ${content}`,
        loader: "js"
      };
    });
  }
};
function aliasPlugin(alias) {
  return {
    name: "alias-plugin",
    setup(build2) {
      build2.onResolve({ filter: /.*/ }, async ({ path: id }) => {
        const matchedEntry = alias.find(({ find: find2 }) => aliasMatches(find2, id));
        if (!matchedEntry)
          return null;
        const { find, replacement } = matchedEntry;
        const result = await build2.resolve(id.replace(find, replacement), {
          kind: "import-statement",
          resolveDir: replacement,
          namespace: "file"
        });
        return {
          path: result.path,
          external: false
        };
      });
    }
  };
}
function aliasMatches(pattern, importee) {
  if (pattern instanceof RegExp)
    return pattern.test(importee);
  if (importee.length < pattern.length)
    return false;
  if (importee === pattern)
    return true;
  return importee.startsWith(`${pattern}/`);
}
async function transformWithEsbuild(entryPoint, options) {
  var _a;
  const { isESM = true, define, alias } = options;
  try {
    const result = await build({
      entryPoints: [entryPoint],
      outfile: "out.js",
      write: false,
      target: ["node16"],
      platform: "node",
      bundle: true,
      metafile: true,
      format: isESM ? "esm" : "cjs",
      define,
      plugins: [aliasPlugin(alias), externalizeDeps, jsonLoader, json5Loader]
    });
    return {
      code: result.outputFiles[0].text,
      deps: ((_a = result.metafile) == null ? void 0 : _a.inputs) || {}
    };
  } catch (e) {
    console.error(e);
  }
  return { code: "", deps: {} };
}
var _dirname = getDirname(import.meta.url);
var _require = createRequire(_dirname);
async function loadFromCode(filepath, code, isESM, cwd) {
  if (isESM) {
    const fileBase = `${filepath}.timestamp-${Date.now()}`;
    const fileNameTmp = `${fileBase}.mjs`;
    const fileUrl = `${pathToFileURL(fileBase)}.mjs`;
    await fsp.writeFile(fileNameTmp, code, "utf8");
    try {
      return await import(fileUrl);
    } finally {
      try {
        fs2.unlinkSync(fileNameTmp);
      } catch {
      }
    }
  } else {
    filepath = path2.resolve(cwd, filepath);
    const extension = path2.extname(filepath);
    const realFileName = fs2.realpathSync(filepath);
    const loaderExt = extension in _require.extensions ? extension : ".js";
    const defaultLoader = _require.extensions[loaderExt];
    _require.extensions[loaderExt] = (module, filename) => {
      if (filename === realFileName) {
        ;
        module._compile(code, filename);
      } else {
        defaultLoader(module, filename);
      }
    };
    delete _require.cache[_require.resolve(filepath)];
    const raw = _require(filepath);
    _require.extensions[loaderExt] = defaultLoader;
    return raw.__esModule ? raw : { default: raw };
  }
}

// src/define.ts
import process from "node:process";
function viteDefine(config) {
  const processNodeEnv = {};
  const nodeEnv = process.env.NODE_ENV || config.mode;
  Object.assign(processNodeEnv, {
    "process.env.NODE_ENV": JSON.stringify(nodeEnv),
    "global.process.env.NODE_ENV": JSON.stringify(nodeEnv),
    "globalThis.process.env.NODE_ENV": JSON.stringify(nodeEnv)
  });
  const userDefine = {};
  const userDefineEnv = {};
  for (const key in config.define) {
    const val = config.define[key];
    const isMetaEnv = key.startsWith("import.meta.env.");
    if (typeof val === "string") {
      if (canJsonParse(val)) {
        userDefine[key] = val;
        isMetaEnv && (userDefineEnv[key.slice(16)] = val);
      }
    } else {
      userDefine[key] = handleDefineValue(val);
      isMetaEnv && (userDefineEnv[key.slice(16)] = val);
    }
  }
  const importMetaKeys = {};
  const importMetaEnvKeys = {};
  const importMetaFallbackKeys = {};
  importMetaKeys["import.meta.hot"] = `undefined`;
  for (const key in config.env) {
    const val = JSON.stringify(config.env[key]);
    importMetaKeys[`import.meta.env.${key}`] = val;
    importMetaEnvKeys[key] = val;
  }
  importMetaFallbackKeys["import.meta.env"] = `undefined`;
  const define = {
    ...processNodeEnv,
    ...importMetaKeys,
    ...userDefine,
    ...importMetaFallbackKeys
  };
  if ("import.meta.env" in define) {
    define["import.meta.env"] = serializeDefine({
      ...importMetaEnvKeys,
      ...userDefineEnv
    });
  }
  return define;
}
function serializeDefine(define) {
  let res = `{`;
  const keys = Object.keys(define);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    const val = define[key];
    res += `${JSON.stringify(key)}: ${handleDefineValue(val)}`;
    if (i !== keys.length - 1)
      res += `, `;
  }
  return `${res}}`;
}
function handleDefineValue(value) {
  if (typeof value === "undefined")
    return "undefined";
  if (typeof value === "string")
    return value;
  return JSON.stringify(value);
}
function canJsonParse(value) {
  try {
    JSON.parse(value);
    return true;
  } catch {
    return false;
  }
}

// src/build.ts
var packageName = true ? "vite-plugin-mock-dev-server" : "vite-plugin-mock-dev-server";
var packageVersion = true ? "1.5.0" : "latest";
async function generateMockServer(ctx, config, options) {
  const include = toArray(options.include);
  const exclude = toArray(options.exclude);
  const define = viteDefine(config);
  const { httpProxies } = ensureProxies(config.server.proxy || {});
  httpProxies.push(...toArray(options.prefix));
  const wsProxies = toArray(options.wsPrefix);
  let pkg = {};
  try {
    const pkgStr = lookupFile(config.root, ["package.json"]);
    if (pkgStr)
      pkg = JSON.parse(pkgStr);
  } catch {
  }
  const outputDir = options.build.dist;
  const content = await generateMockEntryCode(process2.cwd(), include, exclude);
  const mockEntry = path3.join(config.root, `mock-data-${Date.now()}.js`);
  await fsp2.writeFile(mockEntry, content, "utf-8");
  const { code, deps } = await transformWithEsbuild(mockEntry, {
    define,
    alias: config.resolve.alias
  });
  const mockDeps = getMockDependencies(deps, config.resolve.alias);
  await fsp2.unlink(mockEntry);
  const outputList = [
    {
      filename: path3.join(outputDir, "mock-data.js"),
      source: code
    },
    {
      filename: path3.join(outputDir, "index.js"),
      source: generatorServerEntryCode(
        httpProxies,
        wsProxies,
        options.cookiesOptions,
        options.bodyParserOptions,
        options.priority,
        options.build
      )
    },
    {
      filename: path3.join(outputDir, "package.json"),
      source: generatePackageJson(pkg, mockDeps)
    }
  ];
  try {
    if (path3.isAbsolute(outputDir)) {
      for (const { filename } of outputList) {
        if (fs3.existsSync(filename))
          await fsp2.rm(filename);
      }
      config.logger.info(`${c.green("\u2713")} generate mock server in ${c.cyan(outputDir)}`);
      for (const { filename, source } of outputList) {
        fs3.mkdirSync(path3.dirname(filename), { recursive: true });
        await fsp2.writeFile(filename, source, "utf-8");
        const sourceSize = (source.length / 1024).toFixed(2);
        const name = path3.relative(outputDir, filename);
        const space = name.length < 30 ? " ".repeat(30 - name.length) : "";
        config.logger.info(`  ${c.green(name)}${space}${c.bold(c.dim(`${sourceSize} kB`))}`);
      }
    } else {
      for (const { filename, source } of outputList) {
        ctx.emitFile({
          type: "asset",
          fileName: filename,
          source
        });
      }
    }
  } catch (e) {
    console.error(e);
  }
}
function getMockDependencies(deps, alias) {
  const list = /* @__PURE__ */ new Set();
  const excludeDeps = [packageName, "connect", "cors"];
  const isAlias = (p) => alias.find(({ find }) => aliasMatches(find, p));
  Object.keys(deps).forEach((mPath) => {
    const imports = deps[mPath].imports.filter((_) => _.external && !_.path.startsWith("<define:") && !isAlias(_.path)).map((_) => _.path);
    imports.forEach((dep) => {
      if (!excludeDeps.includes(dep) && !isCore(dep))
        list.add(dep);
    });
  });
  return Array.from(list);
}
function generatePackageJson(pkg, mockDeps) {
  const { dependencies = {}, devDependencies = {} } = pkg;
  const dependents = { ...dependencies, ...devDependencies };
  const mockPkg = {
    name: "mock-server",
    type: "module",
    scripts: {
      start: "node index.js"
    },
    dependencies: {
      "connect": "^3.7.0",
      "vite-plugin-mock-dev-server": `^${packageVersion}`,
      "cors": "^2.8.5"
    },
    pnpm: { peerDependencyRules: { ignoreMissing: ["vite"] } }
  };
  mockDeps.forEach((dep) => {
    mockPkg.dependencies[dep] = dependents[dep] || "latest";
  });
  return JSON.stringify(mockPkg, null, 2);
}
function generatorServerEntryCode(httpProxies, wsProxies, cookiesOptions = {}, bodyParserOptions = {}, priority = {}, build2) {
  const { serverPort, log } = build2;
  return `import { createServer } from 'node:http';
import connect from 'connect';
import corsMiddleware from 'cors';
import { baseMiddleware, createLogger, mockWebSocket } from 'vite-plugin-mock-dev-server';
import mockData from './mock-data.js';

const app = connect();
const server = createServer(app);
const logger = createLogger('mock-server', '${log}');
const httpProxies = ${JSON.stringify(httpProxies)};
const wsProxies = ${JSON.stringify(wsProxies)};
const cookiesOptions = ${JSON.stringify(cookiesOptions)};
const bodyParserOptions = ${JSON.stringify(bodyParserOptions)};
const priority = ${JSON.stringify(priority)};

mockWebSocket({ 
  loader: { mockData },
  httpServer: server,
  proxies: wsProxies,
  cookiesOptions,
  logger,
});

app.use(corsMiddleware());
app.use(baseMiddleware({ mockData }, {
  formidableOptions: { multiples: true },
  proxies: httpProxies,
  priority,
  cookiesOptions,
  bodyParserOptions,
  logger,
}));

server.listen(${serverPort});

console.log('listen: http://localhost:${serverPort}');
`;
}
async function generateMockEntryCode(cwd, include, exclude) {
  const includePaths = await fg(include, { cwd });
  const includeFilter = createFilter(include, exclude, {
    resolve: false
  });
  const mockFiles = includePaths.filter(includeFilter);
  let importers = "";
  let exporters = "";
  mockFiles.forEach((filepath, index) => {
    const file = normalizePath(path3.join(cwd, filepath));
    importers += `import * as m${index} from '${file}';
`;
    exporters += `m${index}, `;
  });
  return `import { transformMockData } from 'vite-plugin-mock-dev-server';
${importers}
const exporters = [${exporters}];
const mockList = exporters.map((raw) => {
  let mockConfig
  if (raw.default) {
    mockConfig = raw.default
  } else {
    mockConfig = []
    Object.keys(raw || {}).forEach((key) => {
      Array.isArray(raw[key])
        ? mockConfig.push(...raw[key])
        : mockConfig.push(raw[key])
    })
  }
  return mockConfig
});
export default transformMockData(mockList);`;
}

// src/mockMiddleware.ts
import { isBoolean as isBoolean2, toArray as toArray3, uniq as uniq2 } from "@pengzhanbo/utils";
import cors from "cors";
import { pathToRegexp as pathToRegexp4 } from "path-to-regexp";
import c2 from "picocolors";

// src/baseMiddleware.ts
import { Buffer as Buffer2 } from "node:buffer";
import {
  isArray as isArray3,
  isEmptyObject as isEmptyObject2,
  isFunction,
  random,
  sleep,
  timestamp
} from "@pengzhanbo/utils";
import Cookies from "cookies";
import HTTP_STATUS from "http-status";
import * as mime from "mime-types";
import { pathToRegexp as pathToRegexp2 } from "path-to-regexp";
import colors from "picocolors";

// src/matchingWeight.ts
import {
  isArray,
  isEmptyObject,
  isString,
  sortBy,
  uniq
} from "@pengzhanbo/utils";
import { parse, pathToRegexp } from "path-to-regexp";
var tokensCache = {};
function getTokens(rule) {
  if (tokensCache[rule])
    return tokensCache[rule];
  const tks = parse(rule);
  const tokens = [];
  for (const tk of tks) {
    if (!isString(tk)) {
      tokens.push(tk);
    } else {
      const hasPrefix = tk[0] === "/";
      const subTks = hasPrefix ? tk.slice(1).split("/") : tk.split("/");
      tokens.push(
        `${hasPrefix ? "/" : ""}${subTks[0]}`,
        ...subTks.slice(1).map((t) => `/${t}`)
      );
    }
  }
  tokensCache[rule] = tokens;
  return tokens;
}
function getHighest(rules) {
  let weights = rules.map((rule) => getTokens(rule).length);
  weights = weights.length === 0 ? [1] : weights;
  return Math.max(...weights) + 2;
}
function sortFn(rule) {
  const tokens = getTokens(rule);
  let w = 0;
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    if (!isString(token))
      w += 10 ** (i + 1);
    w += 10 ** (i + 1);
  }
  return w;
}
function preSort(rules) {
  let matched = [];
  const preMatch = [];
  for (const rule of rules) {
    const tokens = getTokens(rule);
    const len = tokens.filter((token) => typeof token !== "string").length;
    if (!preMatch[len])
      preMatch[len] = [];
    preMatch[len].push(rule);
  }
  for (const match2 of preMatch.filter((v) => v && v.length > 0))
    matched = [...matched, ...sortBy(match2, sortFn).reverse()];
  return matched;
}
function defaultPriority(rules) {
  const highest = getHighest(rules);
  return sortBy(rules, (rule) => {
    const tokens = getTokens(rule);
    const dym = tokens.filter((token) => typeof token !== "string");
    if (dym.length === 0)
      return 0;
    let weight = dym.length;
    let exp = 0;
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      const isDynamic = !isString(token);
      const {
        pattern = "",
        modifier,
        prefix,
        name
      } = isDynamic ? token : {};
      const isGlob = pattern && pattern.includes(".*");
      const isSlash = prefix === "/";
      const isNamed = isString(name);
      exp += isDynamic && isSlash ? 1 : 0;
      if (i === tokens.length - 1 && isGlob) {
        weight += 5 * 10 ** (tokens.length === 1 ? highest + 1 : highest);
      } else {
        if (isGlob) {
          weight += 3 * 10 ** (highest - 1);
        } else if (pattern) {
          if (isSlash) {
            weight += (isNamed ? 2 : 1) * 10 ** (exp + 1);
          } else {
            weight -= 1 * 10 ** exp;
          }
        }
      }
      if (modifier === "+")
        weight += 1 * 10 ** (highest - 1);
      if (modifier === "*")
        weight += 1 * 10 ** (highest - 1) + 1;
      if (modifier === "?")
        weight += 1 * 10 ** (exp + (isSlash ? 1 : 0));
    }
    return weight;
  });
}
function matchingWeight(rules, url, priority) {
  let matched = defaultPriority(
    preSort(rules.filter((rule) => pathToRegexp(rule).test(url)))
  );
  const { global = [], special = {} } = priority;
  if (global.length === 0 && isEmptyObject(special) || matched.length === 0)
    return matched;
  const [statics, dynamics] = twoPartMatch(matched);
  const globalMatch = global.filter((rule) => dynamics.includes(rule));
  if (globalMatch.length > 0) {
    matched = uniq([...statics, ...globalMatch, ...dynamics]);
  }
  if (isEmptyObject(special))
    return matched;
  const specialRule = Object.keys(special).filter(
    (rule) => matched.includes(rule)
  )[0];
  if (!specialRule)
    return matched;
  const options = special[specialRule];
  const { rules: lowerRules, when } = isArray(options) ? { rules: options, when: [] } : options;
  if (lowerRules.includes(matched[0])) {
    if (when.length === 0 || when.some((path4) => pathToRegexp(path4).test(url))) {
      matched = uniq([specialRule, ...matched]);
    }
  }
  return matched;
}
function twoPartMatch(rules) {
  const statics = [];
  const dynamics = [];
  for (const rule of rules) {
    const tokens = getTokens(rule);
    const dym = tokens.filter((token) => typeof token !== "string");
    if (dym.length > 0)
      dynamics.push(rule);
    else
      statics.push(rule);
  }
  return [statics, dynamics];
}

// src/parseReqBody.ts
import bodyParser from "co-body";
import formidable from "formidable";
async function parseReqBody(req, formidableOptions, bodyParserOptions = {}) {
  var _a;
  const method = req.method.toUpperCase();
  if (["GET", "DELETE", "HEAD"].includes(method))
    return void 0;
  const type = ((_a = req.headers["content-type"]) == null ? void 0 : _a.toLocaleLowerCase()) || "";
  const { limit, formLimit, jsonLimit, textLimit, ...rest } = bodyParserOptions;
  try {
    if (type.startsWith("application/json")) {
      return await bodyParser.json(req, {
        limit: jsonLimit || limit,
        ...rest
      });
    }
    if (type.startsWith("application/x-www-form-urlencoded")) {
      return await bodyParser.form(req, {
        limit: formLimit || limit,
        ...rest
      });
    }
    if (type.startsWith("text/plain")) {
      return await bodyParser.text(req, {
        limit: textLimit || limit,
        ...rest
      });
    }
    if (type.startsWith("multipart/form-data"))
      return await parseMultipart(req, formidableOptions);
  } catch (e) {
    console.error(e);
  }
  return void 0;
}
async function parseMultipart(req, options) {
  const form = formidable(options);
  return new Promise((resolve, reject) => {
    form.parse(req, (error, fields, files) => {
      if (error) {
        reject(error);
        return;
      }
      resolve({ ...fields, ...files });
    });
  });
}

// src/requestRecovery.ts
import { Buffer } from "node:buffer";
var cache = /* @__PURE__ */ new WeakMap();
function collectRequest(req) {
  const chunks = [];
  req.addListener("data", (chunk) => {
    chunks.push(Buffer.from(chunk));
  });
  req.addListener("end", () => {
    if (chunks.length)
      cache.set(req, Buffer.concat(chunks));
  });
}
function recoverRequest(config) {
  if (!config.server)
    return;
  const proxies = config.server.proxy || {};
  Object.keys(proxies).forEach((key) => {
    const target = proxies[key];
    const options = typeof target === "string" ? { target } : target;
    if (options.ws)
      return;
    const { configure, ...rest } = options;
    proxies[key] = {
      ...rest,
      configure(proxy, options2) {
        configure == null ? void 0 : configure(proxy, options2);
        proxy.on("proxyReq", (proxyReq, req) => {
          const buffer = cache.get(req);
          if (buffer) {
            cache.delete(req);
            if (!proxyReq.headersSent)
              proxyReq.setHeader("Content-Length", buffer.byteLength);
            if (!proxyReq.writableEnded)
              proxyReq.write(buffer);
          }
        });
      }
    };
  });
}

// src/validator.ts
import { isArray as isArray2, isObject } from "@pengzhanbo/utils";
function validate(request, validator) {
  return isObjectSubset(request.headers, validator.headers) && isObjectSubset(request.body, validator.body) && isObjectSubset(request.params, validator.params) && isObjectSubset(request.query, validator.query) && isObjectSubset(request.refererQuery, validator.refererQuery);
}
function isObjectSubset(source, target) {
  if (!target)
    return true;
  for (const key in target) {
    if (!isIncluded(source[key], target[key]))
      return false;
  }
  return true;
}
function isIncluded(source, target) {
  if (isArray2(source) && isArray2(target)) {
    const seen = /* @__PURE__ */ new Set();
    return target.every(
      (ti) => source.some((si, i) => {
        if (seen.has(i))
          return false;
        const included = isIncluded(si, ti);
        if (included)
          seen.add(i);
        return included;
      })
    );
  }
  if (isObject(source) && isObject(target))
    return isObjectSubset(source, target);
  return Object.is(source, target);
}

// src/baseMiddleware.ts
function baseMiddleware(mockLoader, {
  formidableOptions = {},
  bodyParserOptions = {},
  proxies,
  cookiesOptions,
  logger,
  priority = {}
}) {
  return async function(req, res, next) {
    const startTime = timestamp();
    const { query, pathname } = urlParse(req.url);
    if (!pathname || proxies.length === 0 || !proxies.some((context) => doesProxyContextMatchUrl(context, req.url)))
      return next();
    const mockData = mockLoader.mockData;
    const mockUrls = matchingWeight(Object.keys(mockData), pathname, priority);
    if (mockUrls.length === 0)
      return next();
    collectRequest(req);
    const { query: refererQuery } = urlParse(req.headers.referer || "");
    const reqBody = await parseReqBody(req, formidableOptions, bodyParserOptions);
    const cookies = new Cookies(req, res, cookiesOptions);
    const getCookie = cookies.get.bind(cookies);
    const method = req.method.toUpperCase();
    let mock;
    let _mockUrl;
    for (const mockUrl of mockUrls) {
      mock = fineMock(mockData[mockUrl], logger, {
        pathname,
        method,
        request: {
          query,
          refererQuery,
          body: reqBody,
          headers: req.headers,
          getCookie
        }
      });
      if (mock) {
        _mockUrl = mockUrl;
        break;
      }
    }
    if (!mock) {
      const matched = mockUrls.map(
        (m) => m === _mockUrl ? colors.underline(colors.bold(m)) : colors.dim(m)
      ).join(", ");
      logger.warn(
        `${colors.green(
          pathname
        )} matches  ${matched} , but mock data is not found.`
      );
      return next();
    }
    const request = req;
    const response = res;
    request.body = reqBody;
    request.query = query;
    request.refererQuery = refererQuery;
    request.params = parseParams(mock.url, pathname);
    request.getCookie = getCookie;
    response.setCookie = cookies.set.bind(cookies);
    const {
      body,
      delay,
      type = "json",
      response: responseFn,
      status = 200,
      statusText,
      log: logLevel,
      __filepath__: filepath
    } = mock;
    responseStatus(response, status, statusText);
    await provideHeaders(request, response, mock, logger);
    await provideCookies(request, response, mock, logger);
    logger.info(requestLog(request, filepath), logLevel);
    logger.debug(
      `${colors.magenta("DEBUG")} ${colors.underline(
        pathname
      )}  matches: [ ${mockUrls.map(
        (m) => m === _mockUrl ? colors.underline(colors.bold(m)) : colors.dim(m)
      ).join(", ")} ]
`
    );
    if (body) {
      try {
        const content = isFunction(body) ? await body(request) : body;
        await realDelay(startTime, delay);
        sendData(response, content, type);
      } catch (e) {
        logger.error(
          `${colors.red(
            `mock error at ${pathname}`
          )}
${e}
  at body (${colors.underline(filepath)})`,
          logLevel
        );
        responseStatus(response, 500);
        res.end("");
      }
      return;
    }
    if (responseFn) {
      try {
        await realDelay(startTime, delay);
        await responseFn(request, response, next);
      } catch (e) {
        logger.error(
          `${colors.red(
            `mock error at ${pathname}`
          )}
${e}
  at response (${colors.underline(filepath)})`,
          logLevel
        );
        responseStatus(response, 500);
        res.end("");
      }
      return;
    }
    res.end("");
  };
}
function fineMock(mockList, logger, {
  pathname,
  method,
  request
}) {
  return mockList.find((mock) => {
    if (!pathname || !mock || !mock.url || mock.ws === true)
      return false;
    const methods = mock.method ? isArray3(mock.method) ? mock.method : [mock.method] : ["GET", "POST"];
    if (!methods.includes(method))
      return false;
    const hasMock = pathToRegexp2(mock.url).test(pathname);
    if (hasMock && mock.validator) {
      const params = parseParams(mock.url, pathname);
      if (isFunction(mock.validator)) {
        return mock.validator({ params, ...request });
      } else {
        try {
          return validate({ params, ...request }, mock.validator);
        } catch (e) {
          const file = mock.__filepath__;
          logger.error(
            `${colors.red(
              `mock error at ${pathname}`
            )}
${e}
  at validator (${colors.underline(file)})`,
            mock.log
          );
          return false;
        }
      }
    }
    return hasMock;
  });
}
function responseStatus(response, status = 200, statusText) {
  response.statusCode = status;
  response.statusMessage = statusText || getHTTPStatusText(status);
}
async function provideHeaders(req, res, mock, logger) {
  const { headers, type = "json" } = mock;
  const filepath = mock.__filepath__;
  const contentType2 = mime.contentType(type) || mime.contentType(mime.lookup(type) || "");
  contentType2 && res.setHeader("Content-Type", contentType2);
  res.setHeader("Cache-Control", "no-cache,max-age=0");
  res.setHeader("X-Mock-Power-By", "vite-plugin-mock-dev-server");
  filepath && res.setHeader("X-File-Path", filepath);
  if (!headers)
    return;
  try {
    const raw = isFunction(headers) ? await headers(req) : headers;
    Object.keys(raw).forEach((key) => {
      res.setHeader(key, raw[key]);
    });
  } catch (e) {
    logger.error(
      `${colors.red(
        `mock error at ${req.url.split("?")[0]}`
      )}
${e}
  at headers (${colors.underline(filepath)})`,
      mock.log
    );
  }
}
async function provideCookies(req, res, mock, logger) {
  const { cookies } = mock;
  const filepath = mock.__filepath__;
  if (!cookies)
    return;
  try {
    const raw = isFunction(cookies) ? await cookies(req) : cookies;
    Object.keys(raw).forEach((key) => {
      const cookie = raw[key];
      if (isArray3(cookie)) {
        const [value, options] = cookie;
        res.setCookie(key, value, options);
      } else {
        res.setCookie(key, cookie);
      }
    });
  } catch (e) {
    logger.error(
      `${colors.red(
        `mock error at ${req.url.split("?")[0]}`
      )}
${e}
  at cookies (${colors.underline(filepath)})`,
      mock.log
    );
  }
}
function sendData(res, raw, type) {
  if (isReadableStream(raw)) {
    raw.pipe(res);
  } else if (Buffer2.isBuffer(raw)) {
    res.end(type === "text" || type === "json" ? raw.toString("utf-8") : raw);
  } else {
    const content = typeof raw === "string" ? raw : JSON.stringify(raw);
    res.end(type === "buffer" ? Buffer2.from(content) : content);
  }
}
async function realDelay(startTime, delay) {
  if (!delay || typeof delay === "number" && delay <= 0 || isArray3(delay) && delay.length !== 2)
    return;
  let realDelay2 = 0;
  if (isArray3(delay)) {
    const [min, max] = delay;
    realDelay2 = random(min, max);
  } else {
    realDelay2 = delay - (timestamp() - startTime);
  }
  if (realDelay2 > 0)
    await sleep(realDelay2);
}
function getHTTPStatusText(status) {
  return HTTP_STATUS[status] || "Unknown";
}
function requestLog(request, filepath) {
  const { url, method, query, params, body } = request;
  let { pathname } = new URL(url, "http://example.com");
  pathname = colors.green(decodeURIComponent(pathname));
  const format = (prefix, data) => {
    return !data || isEmptyObject2(data) ? "" : `  ${colors.gray(`${prefix}:`)}${JSON.stringify(data)}`;
  };
  const ms = colors.magenta(colors.bold(method));
  const qs = format("query", query);
  const ps = format("params", params);
  const bs = format("body", body);
  const file = `  ${colors.dim(colors.underline(`(${filepath})`))}`;
  return `${ms} ${pathname}${qs}${ps}${bs}${file}`;
}

// src/logger.ts
import { isBoolean } from "@pengzhanbo/utils";
import colors2 from "picocolors";
var logLevels = {
  silent: 0,
  error: 1,
  warn: 2,
  info: 3,
  debug: 4
};
function createLogger(prefix, defaultLevel = "info") {
  prefix = `[${prefix}]`;
  function output(type, msg, level) {
    level = isBoolean(level) ? level ? defaultLevel : "error" : level;
    const thresh = logLevels[level];
    if (thresh >= logLevels[type]) {
      const method = type === "info" || type === "debug" ? "log" : type;
      const tag = type === "debug" ? colors2.magenta(colors2.bold(prefix)) : type === "info" ? colors2.cyan(colors2.bold(prefix)) : type === "warn" ? colors2.yellow(colors2.bold(prefix)) : colors2.red(colors2.bold(prefix));
      const format = `${colors2.dim(
        (/* @__PURE__ */ new Date()).toLocaleTimeString()
      )} ${tag} ${msg}`;
      console[method](format);
    }
  }
  const logger = {
    debug(msg, level = defaultLevel) {
      output("debug", msg, level);
    },
    info(msg, level = defaultLevel) {
      output("info", msg, level);
    },
    warn(msg, level = defaultLevel) {
      output("warn", msg, level);
    },
    error(msg, level = defaultLevel) {
      output("error", msg, level);
    }
  };
  return logger;
}

// src/MockLoader.ts
import EventEmitter from "node:events";
import process3 from "node:process";
import { hasOwn, isArray as isArray5, promiseParallel, toArray as toArray2 } from "@pengzhanbo/utils";
import chokidar from "chokidar";
import fastGlob from "fast-glob";
import { createFilter as createFilter2 } from "@rollup/pluginutils";

// src/transform.ts
import {
  isArray as isArray4,
  isEmptyObject as isEmptyObject3,
  isFunction as isFunction2,
  isObject as isObject2,
  sortBy as sortBy2
} from "@pengzhanbo/utils";
function transformMockData(mockList) {
  const list = [];
  for (const [, handle] of mockList.entries()) {
    if (handle)
      isArray4(handle) ? list.push(...handle) : list.push(handle);
  }
  const mocks = {};
  list.filter((mock) => isObject2(mock) && mock.enabled !== false && mock.url).forEach((mock) => {
    const { pathname, query } = urlParse(mock.url);
    const list2 = mocks[pathname] ??= [];
    const current = { ...mock, url: pathname };
    if (current.ws !== true) {
      const validator = current.validator;
      if (!isEmptyObject3(query)) {
        if (isFunction2(validator)) {
          current.validator = function(request) {
            return isObjectSubset(request.query, query) && validator(request);
          };
        } else if (validator) {
          current.validator = { ...validator };
          current.validator.query = current.validator.query ? { ...query, ...current.validator.query } : query;
        } else {
          current.validator = { query };
        }
      }
    }
    list2.push(current);
  });
  Object.keys(mocks).forEach((key) => {
    mocks[key] = sortByValidator(mocks[key]);
  });
  return mocks;
}
function sortByValidator(mocks) {
  return sortBy2(mocks, (item) => {
    if (item.ws === true)
      return 0;
    const { validator } = item;
    if (!validator || isEmptyObject3(validator))
      return 2;
    if (isFunction2(validator))
      return 0;
    const count = Object.keys(validator).reduce(
      (prev, key) => prev + keysCount(validator[key]),
      0
    );
    return 1 / count;
  });
}
function keysCount(obj) {
  if (!obj)
    return 0;
  return Object.keys(obj).length;
}

// src/MockLoader.ts
var MockLoader = class extends EventEmitter {
  constructor(options) {
    super();
    this.options = options;
    this.cwd = options.cwd || process3.cwd();
    try {
      const pkg = lookupFile(this.cwd, ["package.json"]);
      this.moduleType = !!pkg && JSON.parse(pkg).type === "module" ? "esm" : "cjs";
    } catch (e) {
    }
  }
  moduleCache = /* @__PURE__ */ new Map();
  moduleDeps = /* @__PURE__ */ new Map();
  cwd;
  mockWatcher;
  depsWatcher;
  moduleType = "cjs";
  _mockData = {};
  get mockData() {
    return this._mockData;
  }
  load() {
    const { include, exclude } = this.options;
    const includeFilter = createFilter2(include, exclude, {
      resolve: false
    });
    fastGlob(include, { cwd: this.cwd }).then(
      (files) => files.filter(includeFilter).map((file) => () => this.loadMock(file))
    ).then((loadList) => promiseParallel(loadList, 10)).then(() => this.updateMockList());
    this.watchMockEntry();
    this.watchDeps();
    let timer = null;
    this.on("mock:update", async (filepath) => {
      if (!includeFilter(filepath))
        return;
      await this.loadMock(filepath);
      timer && clearImmediate(timer);
      timer = setImmediate(() => {
        this.updateMockList();
        this.emit("mock:update-end", filepath);
        timer = null;
      });
    });
    this.on("mock:unlink", async (filepath) => {
      if (!includeFilter(filepath))
        return;
      this.moduleCache.delete(filepath);
      this.updateMockList();
      this.emit("mock:update-end", filepath);
    });
  }
  watchMockEntry() {
    const { include } = this.options;
    const [firstGlob, ...otherGlob] = include;
    const watcher = this.mockWatcher = chokidar.watch(firstGlob, {
      ignoreInitial: true,
      cwd: this.cwd
    });
    otherGlob.length > 0 && otherGlob.forEach((glob) => watcher.add(glob));
    watcher.on("add", async (filepath) => {
      filepath = normalizePath(filepath);
      this.emit("mock:update", filepath);
      debug("watcher:add", filepath);
    });
    watcher.on("change", async (filepath) => {
      filepath = normalizePath(filepath);
      this.emit("mock:update", filepath);
      debug("watcher:change", filepath);
    });
    watcher.on("unlink", async (filepath) => {
      filepath = normalizePath(filepath);
      this.emit("mock:unlink", filepath);
      debug("watcher:unlink", filepath);
    });
  }
  /**
   * 监听 mock文件依赖的本地文件变动，
   * mock依赖文件更新，mock文件也一并更新
   */
  watchDeps() {
    const oldDeps = [];
    this.depsWatcher = chokidar.watch([], {
      ignoreInitial: true,
      cwd: this.cwd
    });
    this.depsWatcher.on("change", (filepath) => {
      filepath = normalizePath(filepath);
      const mockFiles = this.moduleDeps.get(filepath);
      mockFiles && mockFiles.forEach((file) => {
        this.emit("mock:update", file);
      });
    });
    this.depsWatcher.on("unlink", (filepath) => {
      filepath = normalizePath(filepath);
      this.moduleDeps.delete(filepath);
    });
    this.on("update:deps", () => {
      const deps = [];
      for (const [dep] of this.moduleDeps.entries())
        deps.push(dep);
      const exactDeps = deps.filter((dep) => !oldDeps.includes(dep));
      exactDeps.length > 0 && this.depsWatcher.add(exactDeps);
    });
  }
  close() {
    var _a, _b;
    (_a = this.mockWatcher) == null ? void 0 : _a.close();
    (_b = this.depsWatcher) == null ? void 0 : _b.close();
  }
  updateMockList() {
    this._mockData = transformMockData(this.moduleCache);
  }
  updateModuleDeps(filepath, deps) {
    Object.keys(deps).forEach((mPath) => {
      const imports = deps[mPath].imports.map((_) => _.path);
      imports.forEach((dep) => {
        if (!this.moduleDeps.has(dep))
          this.moduleDeps.set(dep, /* @__PURE__ */ new Set());
        const cur = this.moduleDeps.get(dep);
        cur.add(filepath);
      });
    });
    this.emit("update:deps");
  }
  async loadMock(filepath) {
    if (!filepath)
      return;
    let isESM = false;
    if (/\.m[jt]s$/.test(filepath))
      isESM = true;
    else if (/\.c[jt]s$/.test(filepath))
      isESM = false;
    else
      isESM = this.moduleType === "esm";
    const { define, alias } = this.options;
    const { code, deps } = await transformWithEsbuild(
      filepath,
      { isESM, define, alias }
    );
    try {
      const raw = await loadFromCode(
        filepath,
        code,
        isESM,
        this.cwd
      ) || {};
      let mockConfig;
      if (hasOwn(raw, "default")) {
        mockConfig = raw.default;
      } else {
        mockConfig = [];
        Object.keys(raw).forEach(
          (key) => mockConfig.push(...toArray2(raw[key]))
        );
      }
      if (isArray5(mockConfig)) {
        mockConfig.forEach((mock) => mock.__filepath__ = filepath);
      } else {
        ;
        mockConfig.__filepath__ = filepath;
      }
      this.moduleCache.set(filepath, mockConfig);
      this.updateModuleDeps(filepath, deps);
    } catch (e) {
      console.error(e);
    }
  }
};

// src/ws.ts
import Cookies2 from "cookies";
import { pathToRegexp as pathToRegexp3 } from "path-to-regexp";
import colors3 from "picocolors";
import { WebSocketServer } from "ws";
function mockWebSocket({
  loader,
  httpServer,
  proxies,
  cookiesOptions,
  logger
}) {
  var _a;
  const hmrMap = /* @__PURE__ */ new Map();
  const poolMap = /* @__PURE__ */ new Map();
  const wssContextMap = /* @__PURE__ */ new WeakMap();
  const getWssMap = (mockUrl) => {
    let wssMap = poolMap.get(mockUrl);
    !wssMap && poolMap.set(mockUrl, wssMap = /* @__PURE__ */ new Map());
    return wssMap;
  };
  const getWss = (wssMap, pathname) => {
    let wss = wssMap.get(pathname);
    !wss && wssMap.set(pathname, wss = new WebSocketServer({ noServer: true }));
    return wss;
  };
  const addHmr = (filepath, mockUrl) => {
    let urlList = hmrMap.get(filepath);
    !urlList && hmrMap.set(filepath, urlList = /* @__PURE__ */ new Set());
    urlList.add(mockUrl);
  };
  const setupWss = (wssMap, wss, mock, context, pathname, filepath) => {
    var _a2;
    try {
      (_a2 = mock.setup) == null ? void 0 : _a2.call(mock, wss, context);
      wss.on("close", () => wssMap.delete(pathname));
      wss.on("error", (e) => {
        logger.error(
          `${colors3.red(
            `WebSocket mock error at ${wss.path}`
          )}
${e}
  at setup (${filepath})`,
          mock.log
        );
      });
    } catch (e) {
      logger.error(
        `${colors3.red(
          `WebSocket mock error at ${wss.path}`
        )}
${e}
  at setup (${filepath})`,
        mock.log
      );
    }
  };
  const emitConnection = (wss, ws, req, connectionList) => {
    wss.emit("connection", ws, req);
    ws.on("close", () => {
      const i = connectionList.findIndex((item) => item.ws === ws);
      if (i !== -1)
        connectionList.splice(i, 1);
    });
  };
  const restartWss = (wssMap, wss, mock, pathname, filepath) => {
    const { cleanupList, connectionList, context } = wssContextMap.get(wss);
    cleanupRunner(cleanupList);
    connectionList.forEach(({ ws }) => ws.removeAllListeners());
    wss.removeAllListeners();
    setupWss(wssMap, wss, mock, context, pathname, filepath);
    connectionList.forEach(
      ({ ws, req }) => emitConnection(wss, ws, req, connectionList)
    );
  };
  (_a = loader.on) == null ? void 0 : _a.call(loader, "mock:update-end", (filepath) => {
    if (!hmrMap.has(filepath))
      return;
    const mockUrlList = hmrMap.get(filepath);
    if (!mockUrlList)
      return;
    for (const mockUrl of mockUrlList.values()) {
      for (const mock of loader.mockData[mockUrl]) {
        if (!mock.ws || mock.__filepath__ !== filepath)
          return;
        const wssMap = getWssMap(mockUrl);
        for (const [pathname, wss] of wssMap.entries())
          restartWss(wssMap, wss, mock, pathname, filepath);
      }
    }
  });
  httpServer == null ? void 0 : httpServer.on("upgrade", (req, socket, head) => {
    const { pathname, query } = urlParse(req.url);
    if (!pathname || proxies.length === 0 || !proxies.some((context) => doesProxyContextMatchUrl(context, req.url)))
      return;
    const mockData = loader.mockData;
    const mockUrl = Object.keys(mockData).find((key) => {
      return pathToRegexp3(key).test(pathname);
    });
    if (!mockUrl)
      return;
    const mock = mockData[mockUrl].find((mock2) => {
      return mock2.url && mock2.ws && pathToRegexp3(mock2.url).test(pathname);
    });
    if (!mock)
      return;
    const filepath = mock.__filepath__;
    addHmr(filepath, mockUrl);
    const wssMap = getWssMap(mockUrl);
    const wss = getWss(wssMap, pathname);
    let wssContext = wssContextMap.get(wss);
    if (!wssContext) {
      const cleanupList = [];
      const context = {
        onCleanup: (cleanup) => cleanupList.push(cleanup)
      };
      wssContext = { cleanupList, context, connectionList: [] };
      wssContextMap.set(wss, wssContext);
      setupWss(wssMap, wss, mock, context, pathname, filepath);
    }
    const request = req;
    const cookies = new Cookies2(req, req, cookiesOptions);
    const { query: refererQuery } = urlParse(req.headers.referer || "");
    request.query = query;
    request.refererQuery = refererQuery;
    request.params = parseParams(mockUrl, pathname);
    request.getCookie = cookies.get.bind(cookies);
    wss.handleUpgrade(request, socket, head, (ws) => {
      logger.info(
        `${colors3.magenta(colors3.bold("WebSocket"))} ${colors3.green(
          req.url
        )} connected ${colors3.dim(`(${filepath})`)}`,
        mock.log
      );
      wssContext.connectionList.push({ req: request, ws });
      emitConnection(wss, ws, request, wssContext.connectionList);
    });
  });
  httpServer == null ? void 0 : httpServer.on("close", () => {
    for (const wssMap of poolMap.values()) {
      for (const wss of wssMap.values()) {
        const wssContext = wssContextMap.get(wss);
        cleanupRunner(wssContext.cleanupList);
        wss.close();
      }
      wssMap.clear();
    }
    poolMap.clear();
    hmrMap.clear();
  });
}
function cleanupRunner(cleanupList) {
  let cleanup;
  while (cleanup = cleanupList.shift())
    cleanup == null ? void 0 : cleanup();
}

// src/mockMiddleware.ts
function mockServerMiddleware(config, options, httpServer, ws) {
  const logger = createLogger(
    "vite:mock",
    isBoolean2(options.log) ? options.log ? "info" : "error" : options.log
  );
  const loader = new MockLoader({
    include: toArray3(options.include),
    exclude: toArray3(options.exclude),
    define: viteDefine(config),
    alias: config.resolve.alias
  });
  loader.load();
  loader.on("mock:update-end", () => {
    if (options.reload)
      ws == null ? void 0 : ws.send({ type: "full-reload" });
  });
  httpServer == null ? void 0 : httpServer.on("close", () => loader.close());
  const { httpProxies } = ensureProxies(config.server.proxy || {});
  const prefix = toArray3(options.prefix);
  const proxies = uniq2([...prefix, ...httpProxies]);
  if (!proxies.length && !toArray3(options.wsPrefix).length)
    logger.warn(`No proxy was configured, mock server will not work. See ${c2.cyan("https://vite-plugin-mock-dev-server.netlify.app/guide/usage")}`);
  mockWebSocket({
    loader,
    httpServer,
    proxies: toArray3(options.wsPrefix),
    cookiesOptions: options.cookiesOptions,
    logger
  });
  const middlewares = [];
  middlewares.push(
    /**
     * 在 vite 的开发服务中，由于插件 的 enforce 为 `pre`，
     * mock 中间件的执行顺序 早于 vite 内部的 cors 中间件执行,
     * 这导致了 vite 默认开启的 cors 对 mock 请求不生效。
     * 在一些比如 微前端项目、或者联合项目中，会由于端口不一致而导致跨域问题。
     * 所以在这里，使用 cors 中间件 来解决这个问题。
     *
     * 同时为了使 插件内的 cors 和 vite 的 cors 不产生冲突，并拥有一致的默认行为，
     * 也会使用 viteConfig.server.cors 配置，并支持 用户可以对 mock 中的 cors 中间件进行配置。
     * 而用户的配置也仅对 mock 的接口生效。
     */
    corsMiddleware(loader, proxies, config, options),
    baseMiddleware(loader, {
      formidableOptions: options.formidableOptions,
      proxies,
      cookiesOptions: options.cookiesOptions,
      bodyParserOptions: options.bodyParserOptions,
      priority: options.priority,
      logger
    })
  );
  return middlewares.filter(Boolean);
}
function corsMiddleware(mockLoader, proxies, config, options) {
  let corsOptions = {};
  const enabled = options.cors === false ? false : config.server.cors !== false;
  if (enabled && config.server.cors !== false) {
    corsOptions = {
      ...corsOptions,
      ...typeof config.server.cors === "boolean" ? {} : config.server.cors
    };
  }
  if (enabled && options.cors !== false) {
    corsOptions = {
      ...corsOptions,
      ...typeof options.cors === "boolean" ? {} : options.cors
    };
  }
  return !enabled ? void 0 : function(req, res, next) {
    const { pathname } = urlParse(req.url);
    if (!pathname || proxies.length === 0 || !proxies.some(
      (context) => doesProxyContextMatchUrl(context, req.url)
    ))
      return next();
    const mockData = mockLoader.mockData;
    const mockUrl = Object.keys(mockData).find(
      (key) => pathToRegexp4(key).test(pathname)
    );
    if (!mockUrl)
      return next();
    cors(corsOptions)(req, res, next);
  };
}

// src/plugin.ts
function mockDevServerPlugin({
  prefix = [],
  wsPrefix = [],
  include = ["mock/**/*.mock.{js,ts,cjs,mjs,json,json5}"],
  exclude = ["**/node_modules/**", "**/.vscode/**", "**/.git/**"],
  reload = false,
  log = "info",
  cors: cors2 = true,
  formidableOptions = {},
  build: build2 = false,
  cookiesOptions = {},
  bodyParserOptions = {},
  priority = {}
} = {}) {
  const pluginOptions = {
    prefix,
    wsPrefix,
    include,
    exclude,
    reload,
    cors: cors2,
    cookiesOptions,
    log,
    formidableOptions: {
      multiples: true,
      ...formidableOptions
    },
    bodyParserOptions,
    priority,
    build: build2 ? Object.assign(
      {
        serverPort: 8080,
        dist: "mockServer",
        log: "error"
      },
      typeof build2 === "object" ? build2 : {}
    ) : false
  };
  const plugins = [serverPlugin(pluginOptions)];
  if (pluginOptions.build)
    plugins.push(buildPlugin(pluginOptions));
  return plugins;
}
function buildPlugin(pluginOptions) {
  let viteConfig = {};
  return {
    name: "vite-plugin-mock-dev-server-generator",
    enforce: "post",
    apply: "build",
    configResolved(config) {
      viteConfig = config;
      config.logger.warn("");
    },
    async buildEnd(error) {
      if (error)
        return;
      if (viteConfig.command !== "build")
        return;
      await generateMockServer(this, viteConfig, pluginOptions);
    }
  };
}
function serverPlugin(pluginOptions) {
  let viteConfig = {};
  return {
    name: "vite-plugin-mock-dev-server",
    enforce: "pre",
    apply: "serve",
    config(config) {
      var _a;
      const wsPrefix = toArray4(pluginOptions.wsPrefix);
      if (wsPrefix.length && ((_a = config.server) == null ? void 0 : _a.proxy)) {
        const proxy = {};
        Object.keys(config.server.proxy).forEach((key) => {
          if (!wsPrefix.includes(key))
            proxy[key] = config.server.proxy[key];
        });
        config.server.proxy = proxy;
      }
      recoverRequest(config);
    },
    configResolved(config) {
      viteConfig = config;
      config.logger.warn("");
    },
    configureServer({ middlewares, config, httpServer, ws }) {
      const middlewareList = mockServerMiddleware(
        config,
        pluginOptions,
        httpServer,
        ws
      );
      middlewareList.forEach((middleware) => middlewares.use(middleware));
    },
    configurePreviewServer({ middlewares, httpServer }) {
      const middlewareList = mockServerMiddleware(
        viteConfig,
        pluginOptions,
        httpServer
      );
      middlewareList.forEach((middleware) => middlewares.use(middleware));
    }
  };
}

// src/defineMock.ts
import { isArray as isArray6 } from "@pengzhanbo/utils";
function defineMock(config) {
  return config;
}
function createDefineMock(transformer) {
  const define = (config) => {
    if (isArray6(config))
      config = config.map((item) => transformer(item) || item);
    else
      config = transformer(config) || config;
    return config;
  };
  return define;
}

// src/defineMockData.ts
import { deepClone, deepEqual, isFunction as isFunction3 } from "@pengzhanbo/utils";
var mockDataCache = /* @__PURE__ */ new Map();
var responseCache = /* @__PURE__ */ new WeakMap();
var staleInterval = 70;
var CacheImpl = class {
  value;
  // 初始化数据的备份，用于 判断 传入的初始化数据是否发生变更
  #initialValue;
  #lastUpdate;
  constructor(value) {
    this.value = value;
    this.#initialValue = deepClone(value);
    this.#lastUpdate = Date.now();
  }
  hotUpdate(value) {
    if (Date.now() - this.#lastUpdate < staleInterval)
      return;
    if (!deepEqual(value, this.#initialValue)) {
      this.value = value;
      this.#initialValue = deepClone(value);
      this.#lastUpdate = Date.now();
    }
  }
};
function defineMockData(key, initialData) {
  if (!mockDataCache.has(key))
    mockDataCache.set(key, new CacheImpl(initialData));
  const cache2 = mockDataCache.get(key);
  cache2.hotUpdate(initialData);
  if (responseCache.has(cache2))
    return responseCache.get(cache2);
  const res = [
    () => cache2.value,
    (val) => {
      if (isFunction3(val))
        val = val(cache2.value) ?? cache2.value;
      cache2.value = val;
    }
  ];
  Object.defineProperty(res, "value", {
    get() {
      return cache2.value;
    },
    set(val) {
      cache2.value = val;
    }
  });
  responseCache.set(cache2, res);
  return res;
}

// src/index.ts
var src_default = mockDevServerPlugin;
export {
  baseMiddleware,
  createDefineMock,
  createLogger,
  src_default as default,
  defineMock,
  defineMockData,
  logLevels,
  mockDevServerPlugin,
  mockWebSocket,
  sortByValidator,
  transformMockData
};
